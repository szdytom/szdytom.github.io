{"meta":{"title":"szdytom's blog","subtitle":null,"description":null,"author":"szdytom","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-15T06:18:49.000Z","updated":"2019-11-27T05:32:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-08-15T04:49:39.000Z","updated":"2019-11-27T05:32:16.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[C++]快速幂","slug":"fast-power","date":"2019-10-28T09:27:44.000Z","updated":"2019-11-27T05:55:03.440Z","comments":true,"path":"2019/10/28/fast-power/","link":"","permalink":"http://yoursite.com/2019/10/28/fast-power/","excerpt":"","text":"解决的问题快速求出 $a^b%m$的值。 朴素算法直接for循环求解： 12long long ans = 1;for (int i = 1; i &lt;= b; ++i) ans = ans * a % m; 快速幂原理朴素算法求解时，如果算$a^4$，其实是把$a^2$算了两次，但相同的计算只要算一次就可以了。用递归求解，令f(x)表示$a^x%m$。可以推出$$f(x) = \\begin{cases} a &amp; x=1 \\\\ f(\\lfloor\\frac{x}{2}\\rfloor)^2 &amp; x\\%2=0 \\\\ f(\\lfloor\\frac{x}{2}\\rfloor)^2 \\times a &amp; x\\%2=1 \\end{cases}$$ 代码实现用递归实现 12","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"[C++]01背包问题","slug":"01-pack","date":"2019-10-27T10:34:42.000Z","updated":"2019-11-27T05:32:16.000Z","comments":true,"path":"2019/10/27/01-pack/","link":"","permalink":"http://yoursite.com/2019/10/27/01-pack/","excerpt":"","text":"基本问题有N件物品和一个容量为V 的背包。放入第$i$件物品耗费的空间是$C_i$，得到的价值是$W_i$。求解将哪些物品装入背包可使价值总和最大。 思路这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即$F[i,v]$表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：$F[i, v] = max{F[i−1,v], F[i−1,v−C_i] + W_i}$ 核心代码12345678memset(F[0], 0, sizeof(F[0]));for (int i = 1; i &lt;= n; ++i) &#123; for (int v = 0; v &lt;= V; ++v) &#123; if (v &gt;= c[i]) F[i][v] = max(F[i-1][v], F[i-1][v-c[i]] + w[i]); else F[i][v] = F[i-1][v]; &#125;&#125;for (int i = 0; i &lt;= V; ++i) ans = max(ans, F[n][i]); 其时间复杂度和空间复杂度都是$O(NV)$， 其中时间复杂度基本上不能再优化了，但空间复杂度却可以优化到$O(V)$。 1234567memset(F, 0, sizeof(F));for (int i = 1; i &lt;= n; ++i) &#123; for (int v = V; v &gt;= c[i]; --v) &#123; F[v] = max(F[v], F[v-c[i]] + w[i]); &#125;&#125;for (int i = 0; i &lt;= V; ++i) ans = max(ans, F[i]); 求方案数看一道题：小A点菜对于这类改变问法的问题，一般只需将状态转移方程中的$max$改成$sum$即可。例如若每件物品均是完全背包中的物品，转移方程即为$F[i,v] = sum{F[i−1,v],F[i,v−C_i]}$ 初始条件是$F[0,0] = 1$。 123456789F[0][0] = 1;for (int i = 1; i &lt;= n; ++i) &#123; for (int v = 0; v &lt;= V; ++v) &#123; if (v &gt;= c[i]) F[i][v] = F[i-1][v] + F[i-1][v-c[i]]; else F[i][v] = F[i-1][v]; &#125;&#125;ans = F[n][V];printf(\"%d\\n\", ans); 求装得尽量满再看一题：装箱问题 [NOIp2001普及组第4题]其实这里$W_i$就是$C_i$。 12345678memset(F, 0, sizeof(F));for (int i = 1; i &lt;= n; ++i) &#123; for (int v = V; v &gt;= c[i]; --v) &#123; F[v] = max(F[v], F[v-c[i]] + c[i]); &#125;&#125;for (int i = 0; i &lt;= V; ++i) ans = max(ans, F[i]);printf(\"%d\\n\", V - ans); 求所有体积可能又来一题：积木城堡求出每个高度的城堡数量。 12345678910111213141516171819202122for (int i = 0; i &lt; n; ++i) &#123; int np = 0; int now; int sum = 0; while (1) &#123; scanf(\"%d\", &amp;now); if (now == -1) break; a[++np] = now; sum += now; &#125; if (max_sum &lt; sum) max_sum = sum; memset(F, 0, sizeof(F)); F[0] = 1; for (int j = 1; j &lt;= np; ++j) &#123; for (int v = sum; v &gt;= a[j]; --v) &#123; if (F[v-a[j]] &amp;&amp; !F[v]) &#123; ++h[v]; F[v] = 1; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"浅析拓扑排序","slug":"topsort","date":"2019-08-16T03:55:20.000Z","updated":"2019-11-27T05:47:50.548Z","comments":true,"path":"2019/08/16/topsort/","link":"","permalink":"http://yoursite.com/2019/08/16/topsort/","excerpt":"","text":"by laihaochenunder 图论九讲 拓扑排序的定义 对一个有向无环图(Directed Acyclic Graph简称DAG) $G$进行拓扑排序，是将$G$中所有顶点排成一个线性序列，使得图中任意一对顶点$u$和$v$，若边$u \\rightarrow v \\in E(G)$，则u在线性序列中出现在$v$之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。其实， 就是给一个有向无环图一个遍历的顺序。但对于任意一条边 $u \\rightarrow v$ 我们还要让$u$排在$v$前面， 所以我们可以通过入度来计算。 拓扑排序解决的问题拓扑排序解决类似于$i$必须排在$j$前的问题。例如：3必须排在5前；4必须排在3前；1必须排在2前；5必须排在1前；那么，顺序可能是4 3 5 1 2 拓扑排序的实现后面拓扑要用入度，可以在建图时顺手加上。 12345for (int i = 1; i &lt;= m; i++) &#123; scanf (\"%d%d\", &amp;a, &amp;b); g[a].push_back(b); rd[b]++;&#125; 我们先把每个入度为零的点入队。 然后再取出队首， 遍历所有它能到达的边，删除从它出发的边（到达的点入度-1）。 判断被遍历到的点中有没有入度为零的点。 如果有， 就把它入队。 如果队列为空， 退出函数 代码实现： 12345678910111213141516171819void topu () &#123; for (int i = 1; i &lt;= n; i++) &#123; if (rd[i] == 0) &#123; q.push(i); &#125; &#125; while (!q.empty()) &#123; int u = q.top(); s.push(u); q.pop(); for (unsigned i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i]; rd[v]--; if (rd[v] == 0) &#123; q.push(v); &#125; &#125; &#125;&#125; 拓扑排序的应用拓扑排序一般用来给DAG一个遍历的顺序， 有了顺序， 我们就可以跑DP啦！ 逃生（hdu4857)这很明显是一道拓扑的题。但是，我们还要把编号小的放在前面。我们可以想到用优先队列解决这个问题。代码与拓扑的模板很相似， 代码就不放出来了。 缩点【模板】P3387这道题看上去只要缩点后， 再跑DP, 但问题是DP的顺序是什么：我们可以想到用拓扑给缩完点后的图一个遍历的顺序。缩点： 12345678910111213141516171819202122232425262728void Tarjan (int u) &#123; deep++; dfn[u] = deep; low[u] = deep; s.push(u); ins[u] = 1; for (unsigned i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i]; if (!dfn[v]) &#123; Tarjan (v); low[u] = min (low[u], low[v]); &#125; else if (ins[v]) &#123; low[u] = min (low[u], low[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; color[u] = u; dis[u] += val[u];//dis是记环的权值用的， val是每个点自己的权值 while (s.top() != u) &#123; color[s.top()] = u;//我们可以直接把环的编号记为缩点的编号 dis[u] += val[s.top()]; ins[s.top()] = 0; s.pop(); &#125; ins[u] = 0; s.pop(); &#125;&#125; 主函数内： 123456789101112131415for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; Tarjan(i); &#125; &#125; //缩点for (int i = 1; i &lt;= n; i++) &#123; for (unsigned j = 0; j &lt; g[i].size(); j++) &#123; int v = g[i][j]; if (color[i] != color[v]) &#123; g1[color[i]].push_back(color[v]);//缩完点后重新建的图 rd[color[v]]++;//入度 &#125; &#125;&#125; 这道题的DP比较简洁， 动态转移方程： （有点类似于松弛操作）， $f_v = \\max {f_v, f_u + D_v}$。所以我们可以直接在拓扑时跑DP， 以减少代码复杂度。 1234567891011121314151617181920212223242526272829vector &lt;int&gt; g1[N]; queue&lt;int&gt; q;int rd[N];int ans;int f[N];//f[i] 表示终点为i的最长路void topu () &#123; //把入度为0的入队列 for(int i = 1; i &lt;= n; i++)&#123; //判断是不是缩点 入度为0 if(!rd[i] &amp;&amp; color[i] == i)&#123; q.push(i); f[i] = dis[i];//初始化,这里的dis就是上面公式里的D &#125; &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); for (unsigned i = 0; i &lt; g1[u].size(); i++)&#123; int v = g1[u][i]; f[v] = max (f[v], f[u] + dis[v]); rd[v]--; if (rd[v] == 0) &#123; q.push(v); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans = max(f[i], ans); &#125; &#125; Ponds（hdu5438）这道题就难了很多， 要先处理几个子问题。 怎样把把所有能去掉的池塘都去掉？其实拓扑排序就可以解决这个问题， 每次把度数减一， 然后判断度数是否为零或一，如果是， 则入队。 怎样计算所有的连通组件（连通块）的点数？可以用dfs或并查集（个人感觉dfs好写）解决。把每个连通分量的点数记录下来，顺手记下它们的值的和。 如果只有一个点的连通组件， 怎么处理？依题意， 就可以不用管这个点。（加个特判） 上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 10005;long long t, n, m, cnt, ans;long long val[N], color[N], col[N], du[N], sum[N];//连通组件的值的和vector &lt;long long&gt; g[N];queue &lt;long long&gt; q;bool vis[N], book[N];//判断这个点是否能用void dfs (int u) &#123;//dfs color[u] = cnt; vis[u] = 1; for (unsigned i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i]; if (vis[v] || book[v]) &#123; continue; &#125; dfs(v); &#125;&#125;void topu () &#123;//拓扑 for (int i = 1; i &lt;= n; i++) &#123; if (du[i] == 0 || du[i] == 1) &#123; vis[i] = 1; book[i] = 1; q.push(i); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (unsigned i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i]; if (vis[v]) &#123; continue; &#125; du[v]--; if (du[v] == 1 || du[v] == 0) &#123; book[v] = 1; vis[v] = 1; q.push(v); &#125; &#125; &#125;&#125;void clean () &#123;//记得初始化 cnt = 0; ans = 0; memset (val, 0, sizeof(val)); memset (color, 0, sizeof(color)); memset (col, 0, sizeof(col)); memset (sum, 0, sizeof(sum)); memset (du, 0, sizeof(du)); memset (vis, 0, sizeof(vis)); memset (book, 0, sizeof(book)); for (int i = 0; i &lt;= n + 5; i++) &#123; g[i].clear(); &#125; while (!q.empty()) &#123; q.pop(); &#125;&#125;int main() &#123; scanf (\"%d\", &amp;t); while (t--) &#123;//毒瘤的多组数据qwq scanf (\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf (\"%d\", &amp;val[i]); &#125; int a, b; for (int i = 1; i &lt;= m; i++) &#123; scanf (\"%d%d\", &amp;a, &amp;b); g[a].push_back(b); g[b].push_back(a); du[a]++; du[b]++; &#125; topu(); memset (vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) &#123; if (!color[i] &amp;&amp; !book[i]) &#123;//神似Tarjan cnt++; dfs(i); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; col[color[i]]++; sum[color[i]] += val[i]; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; if (col[i] % 2 == 1) &#123;//判断是否是由奇数个点组成的 ans += sum[i]; &#125; &#125; printf (\"%lld\\n\", ans); clean(); &#125; return 0;&#125; 总结拓扑只能处理DAG, 把图变成一个线性序列， 利用这一点， 就能解决大多数的拓扑的题了。 @2019-8-15 10:57 广东广州二中","categories":[{"name":"图论九讲","slug":"图论九讲","permalink":"http://yoursite.com/categories/图论九讲/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"浅谈差分约束系统","slug":"cha-fen-yu-shu","date":"2019-07-31T09:37:00.000Z","updated":"2019-11-27T05:32:16.000Z","comments":true,"path":"2019/07/31/cha-fen-yu-shu/","link":"","permalink":"http://yoursite.com/2019/07/31/cha-fen-yu-shu/","excerpt":"","text":"by szTomunder group algorithm - graph 从代数到图论差分约束方程差分约束方程就是形如 $x_i-x_j \\leq w_{ij}$ 或 $x_i-x_j \\geq w_{ij}$ 的方程组 比如说： $\\begin{cases}x_1-x_3 \\leq 5 \\\\ x_1-x_2 \\leq 2 \\\\ x_2-x_1 \\leq 0 \\\\ x_2-x_3 \\leq 2 \\\\ x_3-x_2 \\leq -1 \\\\ x_3-x_1 \\leq -2 \\end{cases}$ 就是一组差分方程。下面是它的一组解： $\\begin{cases}x_1=5 \\\\ x_2=3 \\\\ x_3=1 \\end{cases}$ 一组差分约束方程要么有无穷组解，要么无解。因为如果它有解，那么它的解同时加上一个实数 $k$，依旧是一组解。因为每个数都加$k$，他们任意两个数之间的差是不变的，所以对于不等式没有影响。 $\\mathtt{For}\\ \\mathtt{Example}:$ 上式的解还可以是$\\begin{cases}x_1=6 \\\\ x_2=4 \\\\ x_3=2 \\end{cases}$（同时加$1$） 图论解法多数博客接下来是这么说的： 看到 $x_i - x_j \\leq w_{ij}$有没有想到什么呢？ 可以变形为 $x_i \\leq x_j + w_{ij}$ ,这与单元最短路中的三角形不等式$D_i&lt;=D_j+w_{ij}$非常相似因此，可以把每个变量 $x_i$ 看做有向图中的一个结点$i$,对于约束条件 $X_i - X_j ≤ w_{ij}$ ,从结点$j$向结点i连一条权值为 $w_{ij}$ 的有向边。 这里补充一下：$D_i$就是上面$x_i$的一组解。讲得是没错，然而，凭什么长得像就可以随便乱套呢？首先第一步最开始，我们画张图看看： 比如对于$x_1-x_3 \\leq 5$，如果有当前从1到3的最短路大于5，那么一定会被这条路（$1\\rightarrow3$）替换掉。同理，对于 $x_i-x_j \\leq w_{ij}$，如果有当前从$i$到$j$的最短路大于$w_{ij}$，那么一定会被这条路（$i\\rightarrow j$）替换掉。大于也是同样的原理，可以举一反三。同理可得其它边，以保证在前提（差分约束方程）不被违反的情况下得到最优解。 差分约束系统大于还是小于众所周知，不等式方程是互通的，它们可以互相转换。 $\\mathtt{For}\\ \\mathtt{Example}:$ 刚才的方程组： $\\begin{cases}x_1-x_3 \\leq 5 \\\\x_1-x_2 \\leq 2 \\\\x_2-x_1 \\leq 0 \\\\x_2-x_3 \\leq 2 \\\\x_3-x_2 \\leq -1 \\\\ x_3-x_1 \\leq -2 \\end{cases}$ 等价于： $\\begin{cases}x_3-x_1 \\geq -5 \\\\x_2-x_1 \\geq -2 \\\\x_1-x_2 \\geq 0 \\\\x_3-x_2 \\geq -2 \\\\x_2-x_3 \\geq 1 \\\\ x_1-x_3 \\geq 2 \\end{cases}$ 那么差分约束系统该用大于还是小于呢？事实上，两者都有使用，具体看情况。 小于求最短路得到最大值，大于求最长路得到最小值。 无解情况并不是所有差分约束方程都有解。大致可分为两类： 条件矛盾顾名思义，满足了条件A就无法满足条件B。 $\\mathtt{For}\\ \\mathtt{Example}:$ $\\begin{cases}x_1-x_2 \\leq 5 \\\\ x_2-x_1 \\leq -6\\end{cases}$ 等价于： $\\begin{cases}x_1-x_2\\leq5 \\\\ x_1-x_2\\geq6\\end{cases}$ 无关未知数这个其实不一定算无解，不过和2.2.1判断方法一致，就勉强算无解吧。未知数没有构成强连通分量。 $\\mathtt{For}\\ \\mathtt{Example}:$ $\\begin{cases}x_1-x_2 \\leq 5 \\\\ x_3-x_1 \\leq 2\\\\ x_4-x_5 \\leq 2 \\\\ x_5-x_6 \\leq -3\\end{cases}$ 这里$x_1,x_2,x_3$与$x_4,x_5,x_6$毫无关联。 判断无解最短路有负环或最长路有正环即为无解。 超级源点超级原点连接到所有点，且权值都是0。在求最长路时，可以加入一个超级原点以简化代码。最短路似乎好像也许可能可以加入超级原点，不过容易引起错误。 去除重边重复的边会容易导致错误（误判负环）去重边的伪代码 123456789flag &lt;- 1for i in G[u] if G[u,i].v = v if w better than G[u,i].w set new G[u,i].w flag &lt;- 0;if flag = 1 G[u].append(v, w) 模板代码就是一个spfa模板（最长路）： 1234567891011121314151617181920212223242526bool spfa() &#123; memset(d, 0xef, sizeof(d)); d[0] = 0; q.push(0); tx[0] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = 0; for(unsigned i = 0; i &lt; G[u].size(); ++i) &#123; int v = G[u][i].v; int dis = G[u][i].w; if (d[v] &gt; d[u] + dis) &#123; d[v] = d[u] + dis; if (++tx[v] &gt;= 40) &#123; return 0; &#125; if (!vis[v]) &#123; q.push(v); vis[v] = 1; &#125; &#125; &#125; &#125; return 1;&#125; 最短路时改一下符号： 123if (dis[v] &lt; dis[u] + w) &#123; --snip--&#125; 例题P1993 小K的农场模板题，长短路均可，主要问题是如何插入边： 123456789101112131415scanf(\"%d %d\", &amp;n, &amp;m);for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;t, &amp;a, &amp;b); if (t == 3) &#123; G[a].push_back(node(b, 0)); G[b].push_back(node(a, 0)); &#125; else &#123; scanf(\"%d\", &amp;c); if (t == 1) &#123; G[a].push_back(node(b, c)); &#125; else &#123; G[b].push_back(node(a, -c)); &#125; &#125;&#125; tyvj-p1277 关系运算图好像现在看不到题了： Description给出一有向图，图中每条边都被标上了关系运算符‘&lt;’,‘&gt;’,‘=’。现在要给图中每个顶点标上一个大于等于0,小于等于k的某个整数使所有边上的符号得到满足。若存在这样的k，则求最小的k，若任何k都无法满足则输出NO。例如下表中最小的k为2。结点1&gt;结点2结点2&gt;结点3结点2&gt;结点4结点3=结点4如果存在这样的k，输出最小的k值；否则输出‘NO’。Input共二行，第一行有二个空格隔开的整数n和m。n表示G的结点个数，m表示G的边数，其中1&lt;=n&lt;=1000, 0&lt;=m&lt;=10000。全部结点用1到n标出，图中任何二点之间最多只有一条边，且不存在自环。第二行共有3m个用空格隔开的整数，第3i-2和第3i-1（1&lt;=i&lt;=m）个数表示第i条边的顶点。第3i个数表示第i条边上的符号，其值用集合{-1，0，1}中的数表示：-1表示‘&lt;’, 0 表示‘=’, 1表示‘&gt;’。Output仅一行，如无解则输出‘NO’；否则输出最小的k的值。Sample Input4 41 2 -12 3 02 4 -13 4 -1Sample Output2 模板题，最长路 HDU3440 House Man最短路，如果最高楼在最矮楼左边就翻转高度数组。 @2019-7-31 贵州铜仁镇远古镇","categories":[{"name":"图论九讲","slug":"图论九讲","permalink":"http://yoursite.com/categories/图论九讲/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"[C++]指针","slug":"c-pointer","date":"2019-07-13T12:34:29.000Z","updated":"2019-11-27T05:32:16.000Z","comments":true,"path":"2019/07/13/c-pointer/","link":"","permalink":"http://yoursite.com/2019/07/13/c-pointer/","excerpt":"","text":"指针的用处链表 指针的定义基本概念指针就是指向一个变量或者指针的变量，它里面存储的值是一个内存空间的地址。当然，一个指针也可以指向指针。 代码实现12345int i = 3;int *p = &amp;i;int **q = &amp;p;cout&lt;&lt;p&lt;&lt;\" \"&lt;&lt;*p&lt;&lt;endl;cout&lt;&lt;q&lt;&lt;\" \"&lt;&lt;*q&lt;&lt;\" \"&lt;&lt;**q; 本程序的输出结果可能是: 120x22fec8 30x22fec4 0x22fec8 3 Hint:0x22fec8就是变量i的地址0x22fec4就是指针*p的地址 大家可以举一反三，还可以定义很多其他类型的指针（比如char,double,long long······）,都是同一个原理。 指针进阶之交换两个数的值代码112345678910void change(int x,int y)&#123; int t=x; x=y; y=t;&#125;//mainint a=1,b=2;change(a,b);cout&lt;&lt;a&lt;&lt;b; 输出 11 2 为什么a和b没有交换呢,这是因为当我们把a和b传到函数change的时候,参数x和y相当于只是把参数复制了一遍,并没有改变a和b的值。所以这里我们就需要用到指针。我们可以把参数x和y改成a和b的指针。这样的话，当我们在函数change里面改变x和y的值后，相当于我们就已经把a和b的值改变了。代码如下: 代码2123456789101112void change(int *x,int *y)&#123; int t; t=*x; *x=*y; *y=t;&#125;//mainint a=1,b=2;change(&amp;a,&amp;b);cout&lt;&lt;a&lt;&lt;b; 这样我们就可以将a和b的值交换了。 代码3（difficult）1234567891011void change(int *x, int *y)&#123; int *t; t=x; x=y; y=t;&#125;//mainint a=1,b=2;change(&amp;a,&amp;b);cout&lt;&lt;a&lt;&lt;b; 这一段代码也是做不到交换的，但是呢，有些人可能会问，这个也用了指针啦，上面那个代码怎么就可以这个代码就不行呢？其实他的主要原因就是由于我们知道函数的参数传进来的时候，编译器会把它的参数复制一份，我们这里呢，复制的是这个指针，但是交换的也是指针，所以还是只在函数内有效。也就是说还是只交换了形参没有交换实参。 还没有听明白吗？看图。 最开始： 执行代码2 执行代码3 通过以上的图，我们就能很直观地了解到代码三是如何错的了。 拓展代码4不知道大家刚才有没有注意到,我们在将a和b传递到函数change的时候，在前面加了一个&amp;符号，这个符号的作用是取出变量的地址，所以它叫取址符。 12345678910void change(int &amp;x, int &amp;y)&#123; int t=x; x=y; y=t;&#125;//mainint a=1,b=2;change(a,b);cout&lt;&lt;a&lt;&lt;b; 但是在上面代码中，参数x和y变量前面的符号也是&amp;，可是它的作用就不是取址了。这个符号叫引用符，引用符相当于给变量取了个“别名”，实际上他们两个是同一个变量。所以我们在改变参数x和y的时候，变量a和b也会相应的改变。 数组中的指针指针不仅可以应用在变量中，它还可以应用在数组中，请看如下代码。 用指针访问数组12345int a[5] = &#123;1, 2, 3, 4, 5&#125;;int *p;for(p = a; p &lt; a + 5; p++)&#123; cout&lt;&lt;*p&lt;&lt;\" \";&#125; 输出 11 2 3 4 5 在这个代码中，我们首先定义了指针*p，用来指向数组a的第一个元素a[0],随后我们每次输出指针*p，然后将p++（注意这里的p++是将p原来指向的地址向前挪动一个sizeof(int)，而一个sizeof(int)的刚好是4个字节，是一个int所占用的内存空间。所以在我们当p++之后，p的指针恰好就跳到了数组的下一位）。最后我们要判断，让p不要超过数组a所占的内存空间。 数组与指针的关系数组其实就是一种特殊的指针，所以说访问数组也可以这么写： 1a[3] = 5; 等价于： 1*(a+3)=5; 数组由于是在内存中连续存储的，所以，而数组这个a本身他其实也就是一个指针，当我们访问a[3]时。其实就是在访问诶这个指针后移三位的位置。那么它其实也就等价于a+3在访问里面的内容啦。综上所述，访问数组也可以这么写： 13[a] = 5; //亲测可用 可用此招写出无人可以维护的代码。 结构体中的指针定义结构体指针就是指向结构体的指针： 123456789struct node &#123; int a; double b; long long c;&#125;;//mainnode x;node *p=&amp;x; 这时候p就是一个结构体指针，其类型是node 使用怎么读取/写入结构体指针? 读取用-&gt;运算符 1234//readint a = p-&gt;a;double b = p-&gt;bprintf(\"%lld\\n\", p-&gt;c); 或，如果你愿意写的复杂一点，可以： 1234//read2int a = (*p).a;double b = (*p).b;printf(\"%lld\\n\", (*p).c); 写入也差不多。 123p-&gt;a = 123;p-&gt;b = 1.023;scanf(\"%lld\", &amp;(p-&gt;a)); 复杂的方法就不说了，大家可以举一反三。 6. 申请/释放内存指针申明后是没有内存空间的，必须申请后才有：头文件： 1#include &lt;cstdlib&gt; 申请函数原型： 1void* malloc( std::size_t size ); 函数的参数就是要申请多少个字节(BYTE)的空间。用法： 1int *p = (int*)malloc(sizeof(int)); 结构体也可以这么用： 1node *q = (node*)malloc(sizeof(node)); 释放函数原型： 1void free( void* ptr ); 函数的参数就是你刚才申请的指针。用法： 12free(p);free(q); @2019-7-13 广东广州二中by szTom &amp; ezlmr","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}